<html><head><title>Joel Vandiver Blog</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/assets/css/site.css"/></head><body><section class="hero is-black"><div class="hero-body"><div class="container"><h1 class="title"><a href="/index.html">Joel Vandiver</a></h1><h2 class="subtitle">Full Stack Web Developer</h2></div></div></section><section class="section"><div class="container"><div class="columns"><div class="column is-4"><aside class="menu"><p class="menu-label"><p class="menu-label"><a href="/index.html">Home</a></p></p><p class="menu-label"><p class="menu-label">F# Guide</p></p><ul class="menu-list"><li><a href="/2019-04-06-fs-guide-01-value.html">01 Values</a></li><li><a href="/2019-04-06-fs-guide-02-implicit-vs-explicit.html">02 Implicit vs Explicit Value Declaration</a></li><li><a href="/2019-04-06-fs-guide-03-simple.html">03 Simple Values</a></li><li><a href="/2019-04-06-fs-guide-04-list.html">04 List Values</a></li><li><a href="/2019-05-20-fs-guide-05-option.html">05 Option</a></li></ul><p class="menu-label"><p class="menu-label">Topics</p></p><ul class="menu-list"><li><a href="/2019-12-05-fs-type-method-composition.html">F# Type Method Composition</a></li><li><a href="/2019-09-21-fs-aspnetcore-dependency-injection.html">F# ASP.NET Core Dependency Injection</a></li><li><a href="/2019-12-06-fs-destructuring-params.html">Destructuring Params</a></li><li><a href="/2019-12-06-destructuring-anonymous-records.html">Destructuring Anonymous Records</a></li><li><a href="/2019-12-06-fs-lazy.html">Lazy F#</a></li><li><a href="/2019-12-24-fable-fsx.html">Fable FSX Canvas</a></li><li><a href="/2019-12-07-meta-programming-code-to-write-code.html">META Programming   Code to Write Code</a></li><li><a href="/2019-07-13-functional-iteration.html">Functional Iteration</a></li><li><a href="/2019-12-06-why-fs.html">Why F#?</a></li><li><a href="">Use F# Lazy Evaulation for Integration Testing</a></li><li><a href="/2019-06-18-fs-implicit-vs-explicit.html">F# Implicit vs Explicit</a></li><li><a href="/2019-05-06-fs-precomputation.html">F# Precomputation</a></li><li><a href="/2019-06-19-fs-clone-records.html">F# Clone Records</a></li><li><a href="/2019-06-20-discriminated-unions.html">Discriminated Unions</a></li><li><a href="/2019-07-13-fs-anonymous-records.html">F# Anonymous Records</a></li><li><a href="/2019-07-13-fs-immutability-simplifies.html">F# Immutability Simplifies</a></li><li><a href="/2019-07-30-fs-single-case-discriminated-unions.html">F# Single Case Discriminated Unions</a></li><li><a href="/2019-02-02-fs-perf-collections.html">PERF Experiments for F# Collection Types</a></li><li><a href="/2019-02-02-fs-perf-explorations.html">PERF Experiments in F# Reflection of Types</a></li><li><a href="/2019-04-06-fs-expecto-setup.html">Basic F# Expecto Example</a></li><li><a href="/2019-04-06-fs-test-clone.html">F# Test with Clone and Generator</a></li></ul><p class="menu-label"><p class="menu-label">DevOps</p></p><ul class="menu-list"><li><a href="/2019-12-07-github-blog-comments.html">GitHub Blog Comments</a></li><li><a href="/2019-12-07-docker-sql-server.html">SQL SERVER on Docker</a></li><li><a href="/2019-08-31-my-first-jekyll-post.html">Welcome to Jekyll!</a></li></ul><p class="menu-label"><p class="menu-label">Fun</p></p><ul class="menu-list"><li><a href="/2019-09-04-nasa-apod.html">NASA APOD</a></li></ul><p class="menu-label"><p class="menu-label">LEAD</p></p><ul class="menu-list"><li><a href="/2019-12-06-reflection-in-leadership.html">Reflection on Leadership</a></li></ul></aside></div><div class="column is-8"><div id="nasa-img-container"></div><div class="content"><h1><a name="immutability-reduces-information-domain" class="anchor" href="#immutability-reduces-information-domain">Immutability Reduces Information Domain</a></h1><p>I have heard many developers who come from non-functional programming languages such as C++ and C# claim that immutability is overly restrictive.  It is true that immutability is restrictive, but this restriction comes at one huge benefit:  reduction of possible outcomes.  </p>
<p><code>Information</code> may be informally defined as the element of surprise.  The more surprises a system has, the more information it contains.  Note the distinction between actual information and possible information.  Typically as developers we focus our algorithms on the actual information that our system processes.  But, of equal (or greater) concern is of the possible information the system will proccess.  Let&#39;s call this the <code>Information Domain</code>.  Effectively, it is the concern of the developer to process the Information Domain.  We have to anticipate all of the possible outcomes of our system.  </p>
<p>Mutability at its core allows for surprise.  </p>
<p>Let&#39;s take a simple mathematical function and restricted domain for example.</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> f x = x + <span class="hljs-number">3</span>
<span class="hljs-keyword">let</span> domainX = [<span class="hljs-number">-2</span>;<span class="hljs-number">-1</span>;<span class="hljs-number">0</span>;<span class="hljs-number">1</span>;<span class="hljs-number">2</span>]
<span class="hljs-keyword">let</span> table = domainX |&gt; List.map f</code></pre>
<blockquote>
<p>Output:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">val</span> f : x:int -&gt; int
<span class="hljs-keyword">val</span> domainX : int list = [<span class="hljs-number">-2</span>; <span class="hljs-number">-1</span>; <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; <span class="hljs-number">2</span>]
<span class="hljs-keyword">val</span> table : int list = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>; <span class="hljs-number">4</span>; <span class="hljs-number">5</span>]</code></pre>
</blockquote>
<p>Now, let&#39;s explore the same function with a mutable side-effect:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mutable</span> X = <span class="hljs-number">4</span>

<span class="hljs-keyword">let</span> f' x =
    X &lt;- X + <span class="hljs-number">1</span>
    X + x + <span class="hljs-number">3</span>

<span class="hljs-keyword">let</span> table' = domainX |&gt; List.map f'
<span class="hljs-keyword">let</span> table'<span class="hljs-number">2</span> = domainX |&gt; List.map f'</code></pre>
<blockquote>
<p>Output:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">val</span> <span class="hljs-keyword">mutable</span> X : int = <span class="hljs-number">14</span>
<span class="hljs-keyword">val</span> f' : x:int -&gt; int
<span class="hljs-keyword">val</span> table' : int list = [<span class="hljs-number">6</span>; <span class="hljs-number">8</span>; <span class="hljs-number">10</span>; <span class="hljs-number">12</span>; <span class="hljs-number">14</span>]
<span class="hljs-keyword">val</span> table'<span class="hljs-number">2</span> : int list = [<span class="hljs-number">11</span>; <span class="hljs-number">13</span>; <span class="hljs-number">15</span>; <span class="hljs-number">17</span>; <span class="hljs-number">19</span>]</code></pre>
<p>Note the <code>table&#39;2</code> has different values from the values in <code>table&#39;</code> as expected.</p>
</blockquote>
<p>This may seem simple when you can <em>read</em> the source code as we are doing here, but if you did not have access to the source code, this behavior would surely be a <strong>surprise</strong>.</p>
<p>The <code>f&#39;</code> can be restructured to make the behavior less of a surprise:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> f'' x y = y + x + <span class="hljs-number">3</span></code></pre>
<p>Here, we&#39;ve removed the mutable call, and instead declared a new param, <code>y</code>, that declares the dependency for <code>f&#39;&#39;</code> to operate.  </p>
<p>Now, we can provide another restricted domain for the <code>y</code> param:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> domainY = [<span class="hljs-number">4</span>;<span class="hljs-number">5</span>;<span class="hljs-number">6</span>;<span class="hljs-number">7</span>;<span class="hljs-number">8</span>;<span class="hljs-number">9</span>]</code></pre>
<p>This has the effect of combining both <code>domainX</code> and <code>domainY</code> through a cartesian product:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> table'<span class="hljs-number">3</span> =
    domainX
    |&gt; List.map(<span class="hljs-keyword">fun</span> x -&gt; domainY |&gt; List.map (f'' x))
    |&gt; List.concat</code></pre>
<blockquote>
<p>Output:</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">val</span> f'' : x:int -&gt; y:int -&gt; int
<span class="hljs-keyword">val</span> domainY : int list = [<span class="hljs-number">4</span>; <span class="hljs-number">5</span>; <span class="hljs-number">6</span>; <span class="hljs-number">7</span>; <span class="hljs-number">8</span>; <span class="hljs-number">9</span>]
<span class="hljs-keyword">val</span> table'<span class="hljs-number">3</span> : int list =
  [<span class="hljs-number">5</span>; <span class="hljs-number">6</span>; <span class="hljs-number">7</span>; <span class="hljs-number">8</span>; <span class="hljs-number">9</span>; <span class="hljs-number">10</span>; <span class="hljs-number">6</span>; <span class="hljs-number">7</span>; <span class="hljs-number">8</span>; <span class="hljs-number">9</span>; <span class="hljs-number">10</span>; <span class="hljs-number">11</span>; <span class="hljs-number">7</span>; <span class="hljs-number">8</span>; <span class="hljs-number">9</span>; <span class="hljs-number">10</span>; <span class="hljs-number">11</span>; <span class="hljs-number">12</span>; <span class="hljs-number">8</span>; <span class="hljs-number">9</span>; <span class="hljs-number">10</span>; <span class="hljs-number">11</span>;
   <span class="hljs-number">12</span>; <span class="hljs-number">13</span>; <span class="hljs-number">9</span>; <span class="hljs-number">10</span>; <span class="hljs-number">11</span>; <span class="hljs-number">12</span>; <span class="hljs-number">13</span>; <span class="hljs-number">14</span>]</code></pre>
</blockquote>
<p>By allowing mutation, we&#39;ve increased the element of surprise.  I have found this aspect of mutation especially difficult to reason about in large code bases.  </p>
<p>Restrictions are not always an inhibitor, rather they can play a central role in improving the speed and effeciency in development.</p>
</div></div></div></div></section><script src="/assets/js/site.js"></script></body></html>