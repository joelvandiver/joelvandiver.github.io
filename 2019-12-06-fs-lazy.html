<html><head><title>Joel Vandiver Blog</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/assets/css/site.css"/></head><body><section class="hero is-black"><div class="hero-body"><div class="container"><h1 class="title"><a href="/index.html">Joel Vandiver</a></h1><h2 class="subtitle">Full Stack Web Developer</h2></div></div></section><section class="section"><div class="container"><div class="columns"><div class="column is-4"><aside class="menu"><p class="menu-label"><p class="menu-label"><a href="/index.html">Home</a></p></p><p class="menu-label"><p class="menu-label">F# Guide</p></p><ul class="menu-list"><li><a href="/2019-04-06-fs-guide-01-value.html">01 Values</a></li><li><a href="/2019-04-06-fs-guide-02-implicit-vs-explicit.html">02 Implicit vs Explicit Value Declaration</a></li><li><a href="/2019-04-06-fs-guide-03-simple.html">03 Simple Values</a></li><li><a href="/2019-04-06-fs-guide-04-list.html">04 List Values</a></li><li><a href="/2019-05-20-fs-guide-05-option.html">05 Option</a></li></ul><p class="menu-label"><p class="menu-label">Topics</p></p><ul class="menu-list"><li><a href="/2019-12-05-fs-type-method-composition.html">F# Type Method Composition</a></li><li><a href="/2019-09-21-fs-aspnetcore-dependency-injection.html">F# ASP.NET Core Dependency Injection</a></li><li><a href="/2019-12-06-fs-destructuring-params.html">Destructuring Params</a></li><li><a href="/2019-12-06-destructuring-anonymous-records.html">Destructuring Anonymous Records</a></li><li><a href="/2019-12-06-fs-lazy.html">Lazy F#</a></li><li><a href="/2019-12-24-fable-fsx.html">Fable FSX Canvas</a></li><li><a href="/2019-12-07-meta-programming-code-to-write-code.html">META Programming   Code to Write Code</a></li><li><a href="/2019-07-13-functional-iteration.html">Functional Iteration</a></li><li><a href="/2019-12-06-why-fs.html">Why F#?</a></li><li><a href="">Use F# Lazy Evaulation for Integration Testing</a></li><li><a href="/2019-06-18-fs-implicit-vs-explicit.html">F# Implicit vs Explicit</a></li><li><a href="/2019-05-06-fs-precomputation.html">F# Precomputation</a></li><li><a href="/2019-06-19-fs-clone-records.html">F# Clone Records</a></li><li><a href="/2019-06-20-discriminated-unions.html">Discriminated Unions</a></li><li><a href="/2019-07-13-fs-anonymous-records.html">F# Anonymous Records</a></li><li><a href="/2019-07-13-fs-immutability-simplifies.html">F# Immutability Simplifies</a></li><li><a href="/2019-07-30-fs-single-case-discriminated-unions.html">F# Single Case Discriminated Unions</a></li><li><a href="/2019-02-02-fs-perf-collections.html">PERF Experiments for F# Collection Types</a></li><li><a href="/2019-02-02-fs-perf-explorations.html">PERF Experiments in F# Reflection of Types</a></li><li><a href="/2019-04-06-fs-expecto-setup.html">Basic F# Expecto Example</a></li><li><a href="/2019-04-06-fs-test-clone.html">F# Test with Clone and Generator</a></li></ul><p class="menu-label"><p class="menu-label">DevOps</p></p><ul class="menu-list"><li><a href="/2019-12-07-github-blog-comments.html">GitHub Blog Comments</a></li><li><a href="/2019-12-07-docker-sql-server.html">SQL SERVER on Docker</a></li><li><a href="/2019-08-31-my-first-jekyll-post.html">Welcome to Jekyll!</a></li></ul><p class="menu-label"><p class="menu-label">Fun</p></p><ul class="menu-list"><li><a href="/2019-09-04-nasa-apod.html">NASA APOD</a></li></ul><p class="menu-label"><p class="menu-label">LEAD</p></p><ul class="menu-list"><li><a href="/2019-12-06-reflection-in-leadership.html">Reflection on Leadership</a></li></ul></aside></div><div class="column is-8"><div id="nasa-img-container"></div><div class="content"><h1><a name="use-f-lazy-evaluation-for-integration-testing" class="anchor" href="#use-f-lazy-evaluation-for-integration-testing">Use F# Lazy Evaluation for Integration Testing</a></h1><p>F#&#39;s <code>lazy</code> keyword is incredibly powerful at encapsulating expensive operations in integration testing.  If you need to make a web request, run a database query, or the like, you can wrap your call with a <code>lazy ()</code> to shield the environment from this work.  </p>
<p>Often in integration testing, you may need one of these expensive operations.  Each of the tests may be run independently or in parallel.  </p>
<h2><a name="simply-code-lazy-code-" class="anchor" href="#simply-code-lazy-code-">Simply <code>lazy</code></a></h2><p>First, let&#39;s explore the keyword.</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">lazy</span> (<span class="hljs-number">5</span> + <span class="hljs-number">4</span>)    <span class="hljs-comment">// val x : Lazy&lt;int&gt; = Value is not created.</span>
<span class="hljs-keyword">let</span> y = x.Force()       <span class="hljs-comment">// val y : int = 9</span></code></pre>
<p>So, to get the value <code>9</code> out of <code>x</code>, you have to apply force to get the lazy value.  </p>
<blockquote>
<p>Just as with a <code>lazy</code> person, you have to <code>Force</code> them to do some work.</p>
</blockquote>
<h2><a name="actually-code-lazy-code-" class="anchor" href="#actually-code-lazy-code-">Actually <code>lazy</code></a></h2><p>What&#39;s actually going on behind the scenes with the <code>Force</code>? </p>
<p>Let&#39;s set up an example that includes a print in the worker so that we can see the what&#39;s happening in the work.</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mutable</span> count = <span class="hljs-number">0</span>                <span class="hljs-comment">// val mutable count : int = 1</span>
<span class="hljs-keyword">let</span> work () =                        <span class="hljs-comment">// val work : unit -&gt; int</span>
    printfn <span class="hljs-string">"Starting Num %i"</span> count
    count &lt;- count + <span class="hljs-number">1</span>
    count                                            
<span class="hljs-keyword">let</span> num = <span class="hljs-keyword">lazy</span> (work())              <span class="hljs-comment">// val num : Lazy&lt;int&gt; = 1</span>
<span class="hljs-keyword">let</span> nums =
    [
        num
        num
        num
        num
    ]
    |&gt; List.map(<span class="hljs-keyword">fun</span> num -&gt; num.Force())
<span class="hljs-comment">// Output:  Starting Num 0</span>
<span class="hljs-comment">// val nums : int list = [1; 1; 1; 1;]</span></code></pre>
<p>Note, the &quot;Starting Num _&quot; was only printed once, and the successive <code>Force</code> of the <code>lazy</code> value did not increment the counter.</p>
<h2><a name="being-code-lazy-code-can-be-a-good-thing-" class="anchor" href="#being-code-lazy-code-can-be-a-good-thing-">Being <code>lazy</code> can be a good thing.</a></h2><p>Now, let&#39;s setup a more typical scenario for integration testing.</p>
<pre><code class="language-fsharp"><span class="hljs-keyword">let</span> workHard =
    <span class="hljs-keyword">lazy</span> (
        <span class="hljs-comment">// Do this</span>
        ...

        <span class="hljs-comment">// Do that</span>
        ...

        <span class="hljs-comment">// Return a value.</span>
        <span class="hljs-keyword">let</span> hardWork = ...

        hardWork
    )

<span class="hljs-keyword">let</span> test1 () = 
    <span class="hljs-comment">// Arrange: Work</span>
    <span class="hljs-keyword">let</span> hardWork = workHard.Force()
    <span class="hljs-comment">// Act: Use hardWork</span>
    ...

    <span class="hljs-comment">// Assert</span>
    ...

<span class="hljs-keyword">let</span> test2 () = 
    <span class="hljs-comment">// Arrange: Work</span>
    <span class="hljs-keyword">let</span> hardWork = workHard.Force()
    <span class="hljs-comment">// Act: Use hardWork</span>
    ...

    <span class="hljs-comment">// Assert</span>
    ...
</code></pre>
<p>The two tests above (<code>test1</code> and <code>test2</code>) can be run independently, in series, or in parallel, and the <code>workHard</code> value will only be computed once.  Very nice!</p>
</div></div></div></div></section><script src="/assets/js/site.js"></script></body></html>