<html><head><title>Joel Vandiver Blog</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/assets/css/site.css"/></head><body><section class="hero is-black"><div class="hero-body"><div class="container"><h1 class="title"><a href="/index.html">Joel Vandiver</a></h1><h2 class="subtitle">Full Stack Web Developer</h2></div></div></section><section class="section"><div class="container"><div class="columns"><div class="column is-4"><aside class="menu"><p class="menu-label"><p class="menu-label"><a href="/index.html">Home</a></p></p><p class="menu-label"><p class="menu-label">F# Guide</p></p><ul class="menu-list"><li><a href="/2019-04-06-fs-guide-01-value.html">01 Values</a></li><li><a href="/2019-04-06-fs-guide-02-implicit-vs-explicit.html">02 Implicit vs Explicit Value Declaration</a></li><li><a href="/2019-04-06-fs-guide-03-simple.html">03 Simple Values</a></li><li><a href="/2019-04-06-fs-guide-04-list.html">04 List Values</a></li><li><a href="/2019-05-20-fs-guide-05-option.html">05 Option</a></li></ul><p class="menu-label"><p class="menu-label">Topics</p></p><ul class="menu-list"><li><a href="/2019-12-05-fs-type-method-composition.html">F# Type Method Composition</a></li><li><a href="/2019-09-21-fs-aspnetcore-dependency-injection.html">F# ASP.NET Core Dependency Injection</a></li><li><a href="/2019-12-06-fs-destructuring-params.html">Destructuring Params</a></li><li><a href="/2019-12-06-destructuring-anonymous-records.html">Destructuring Anonymous Records</a></li><li><a href="/2019-12-06-fs-lazy.html">Lazy F#</a></li><li><a href="/2019-12-24-fable-fsx.html">Fable FSX Canvas</a></li><li><a href="/2019-12-07-meta-programming-code-to-write-code.html">META Programming   Code to Write Code</a></li><li><a href="/2019-07-13-functional-iteration.html">Functional Iteration</a></li><li><a href="/2019-12-06-why-fs.html">Why F#?</a></li><li><a href="">Use F# Lazy Evaulation for Integration Testing</a></li><li><a href="/2019-06-18-fs-implicit-vs-explicit.html">F# Implicit vs Explicit</a></li><li><a href="/2019-05-06-fs-precomputation.html">F# Precomputation</a></li><li><a href="/2019-06-19-fs-clone-records.html">F# Clone Records</a></li><li><a href="/2019-06-20-discriminated-unions.html">Discriminated Unions</a></li><li><a href="/2019-07-13-fs-anonymous-records.html">F# Anonymous Records</a></li><li><a href="/2019-07-13-fs-immutability-simplifies.html">F# Immutability Simplifies</a></li><li><a href="/2019-07-30-fs-single-case-discriminated-unions.html">F# Single Case Discriminated Unions</a></li></ul><p class="menu-label"><p class="menu-label">DevOps</p></p><ul class="menu-list"><li><a href="/2019-12-07-github-blog-comments.html">GitHub Blog Comments</a></li><li><a href="/2019-12-07-docker-sql-server.html">SQL SERVER on Docker</a></li><li><a href="/2019-08-31-my-first-jekyll-post.html">Welcome to Jekyll!</a></li></ul><p class="menu-label"><p class="menu-label">Fun</p></p><ul class="menu-list"><li><a href="/2019-09-04-nasa-apod.html">NASA APOD</a></li></ul><p class="menu-label"><p class="menu-label">LEAD</p></p><ul class="menu-list"><li><a href="/2019-12-06-reflection-in-leadership.html">Reflection on Leadership</a></li></ul></aside></div><div class="column is-8"><div id="nasa-img-container"></div><div class="content"><h1><a name="why-f-" class="anchor" href="#why-f-">Why F#?</a></h1><p>I became a .NET developer after I taught high school Math for several years.  I also spent sometime as a Physics major in college.  I&#39;ve always gravitated towards the simplicity of Mathematics.</p>
<h2><a name="imperative-code" class="anchor" href="#imperative-code">Imperative Code</a></h2><p>After gaining some level of competence in C#, I began to explore the more Math-<em>like</em> qualities of .NET programming.  In fact, the hardest time I had with C# was with the non-Math-<em>like</em> aspects.  </p>
<p>I remember coming across a method that returned nothing.  </p>
<p>What purpose could a function have if it didn&#39;t return anything?  To make matters more confusing, the method&#39;s side effect was to mutate the object in memory only.  </p>
<blockquote>
<p>This felt like magic to me, but not the delightful kind of magic...more like the magic that brought terror.  </p>
</blockquote>
<p>How could I predict what was going on in the system that changed itself through the call stack?  </p>
<p>Well, I would have to read the code to fully understand the command line after line.  That&#39;s my informal definition of &quot;Imperative Code&quot;.  <strong>There has to be a better way.</strong></p>
<h2><a name="what-the-code-void-code-" class="anchor" href="#what-the-code-void-code-">What the <code>void</code>?</a></h2><p>First, what is <code>void</code>?</p>
<ul>
<li>How can you use <code>void</code>?</li>
<li>What does it mean to call a function that does not return something?</li>
</ul>
<p>In Math, we write functions such as:</p>
<p><code>f(x) = x + 3</code></p>
<p>This function takes a value, <code>x</code>, and returns a value, <code>f(x)</code>.</p>
<p>So, I did come to understand that <code>void</code> methods only have value if they have a side effect.  The function may issue a command against a database, send a <code>POST</code> request to another api, or mutate the one of the object parameters, etc.</p>
<h2><a name="what-about-ambiguity-" class="anchor" href="#what-about-ambiguity-">What about ambiguity?</a></h2><p>That&#39;s great that you can call a function to do this <em>work</em>, but <em>by definition</em> this is <strong>non-deterministic</strong>.  You cannot precisely define the remote resource being used, or the state of the object before and after mutation, etc.</p>
<p>On the other hand, you can&#39;t have a very helpful application if it did not have side effects some where.  </p>
<ul>
<li>How would the user interact with the application without some form of side effects to convey the application state?  </li>
<li>How can the outside world be changed by the application without changing state as side effects?  </li>
</ul>
<h2><a name="enter-clarity-" class="anchor" href="#enter-clarity-">Enter clarity.</a></h2><p>Though side effects are necessary, can we at least shield a majority of our codebase to the <strong>boundary</strong> of our application?  This will aide us tremendously in reasoning about predictable functions.  <code>UNIT</code> testing becomes a simple answer of <em>input this and verify this output.</em>  </p>
<h2><a name="enter-f-" class="anchor" href="#enter-f-">Enter F#.</a></h2><p>F# provides immutability of functions by default.  Functions by default simply take inputs and return outputs.  </p>
<p>You can then write simple, easily testable functions.  You can compose them up the stack into more complex structures.  </p>
<p>So, here&#39;s a short list of the many reasons that I made the switch to F#:</p>
<ol>
<li>Immutability by Default - Mutabilty by Choice</li>
<li>Code Succinctness &amp; Brevity</li>
<li>Function-First (rather than Class-First)</li>
<li>Function Composition</li>
<li>Function Chaining</li>
<li>Higher Order Functions</li>
<li>Simple Functional Data Structures (Records, Options, etc.)</li>
</ol>
</div></div></div></div></section><script src="/assets/js/site.js"></script></body></html>